#![doc = include_str!("../README.md")]
#![cfg_attr(not(any(doc, test)), no_std)]
// This only refuses unsafe code in functions/expressions in this crate, not ones generated by this
// crate's macros.
#![cfg_attr(not(any(doc, test)), forbid(unsafe_code))]
//#[cfg(doc)]
//extern crate alloc;

/// Invoke am unsafe function.
#[macro_export]
macro_rules! unsafe_fn {
    ( $fn:expr $(, $arg:expr)+ ) => {
        // Enclosed in a block, so that
        // 1. the result can be used as a value in an outer expression,and
        // 2. local variables don't conflict with the outer scope
        {
            let tuple = $crate::unsafe_fn!{~~ $($arg),* };
            let fun = $fn;
            $crate::unsafe_fn! {~~~
                fun,
                tuple,
                ( $( $arg ),* ),
                (0)
            }
        }
    };
    ($fn:expr) => {
        ::core::compile_error!("For now, we require the (potentially unsafe) function to have at least 1 argument.")
    };

    // Construct the tuple:
    (~~ $first:expr, $($rest:expr),+ ) => {
        (
            $first, $crate::unsafe_fn!{ ~~ $($rest),+ }
        )
    };
    (~~ $last:expr) => {
        ($last,)
    };
    // Commented out: For now, we require the (potentially unsafe) function to have at least 1 argument.
    //
    //(~~) => { () };

    // Access tuple parts and call the function:
    (~~~ $fn:expr, $tuple:ident,
     ( $_first_arg:expr, $($other_arg:expr),+ ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        $crate::unsafe_fn!{ ~~~
            $fn, $tuple, ( $($other_arg),+ ),
            // Insert a new accessor to front (left): 0.
            (0),
            $(  // Prepend 1 to each supplied/existing accessor
                 ( 1, $($accessor_part),+ )
            ),*
        }
    };
    // All accessors are ready, so call the function:
    (~~~ $fn:expr, $tuple:ident,
     ( $_last_or_only_arg:expr ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        unsafe {
            $fn( $(
                    $crate::unsafe_fn!{ ~~~~ $tuple, $($accessor_part),+ }
                ),*
            )
        }
    };

    // Expand an accessor group/list to access a field in the tuple:
    (~~~~ $tuple:ident, $($accessor_part:tt),* ) => {
        $tuple $(. $accessor_part )*
    };
}
//-------------

/// Invoke am unsafe method. Like [unsafe_fn], but
/// - we accept a receiver `self`
/// - we store `self` in a variable outside of the generated `unsafe {...}`
/// - we don't allow $fn to be an expression (which doesn't work in standard methods calls), but
///   only an identifier.
#[macro_export]
macro_rules! unsafe_method {
    ($self:expr, $fn:ident $(, $arg:expr)+ ) => {
        // Enclosed in a block, so that
        // 1. the result can be used as a value in an outer expression,and
        // 2. local variables don't conflict with the outer scope
        {
            let tuple = $crate::unsafe_fn!{~~ $($arg),* }; // re-using unsafe_fn
            let receiver = $self;
            $crate::unsafe_method! {~~~
                receiver,
                $fn,
                tuple,
                ( $( $arg ),* ),
                (0)
            }
        }
    };

    // Access tuple parts and call the function:
    (~~~ $self:expr, $fn:ident, $tuple:ident,
     ( $_first_arg:expr, $($other_arg:expr),+ ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        $crate::unsafe_method!{ ~~~
            $self, $fn, $tuple, ( $($other_arg),+ ),
            // Insert a new accessor to front (left): 0.
            (0),
            $(  // Prepend 1 to each supplied/existing accessor
                 ( 1, $($accessor_part),+ )
            ),*
        }
    };
    // All accessors are ready, so call the function:
    (~~~ $self:expr, $fn:ident, $tuple:ident,
     ( $_last_or_only_arg:expr ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        unsafe {
            $self. $fn( $(
                    $crate::unsafe_fn!{ ~~~~ $tuple, $($accessor_part),+ }
                ),*
            )
        }
    };
}

//-------------

#[cfg(test)]
mod tests {
    unsafe fn unsafe_a(_: char, b: bool, _: u8, _: i32) -> bool {
        b
    }

    #[test]
    fn it_works() {
        //let tuple = unsafe_fn!{~~  'c', true, 1, -5 };
        unsafe_fn!(unsafe_a, 'c', true, 1, -5);

        //unsafe fn f() {}
        //unsafe_fn!( f);

        /*let args = ('c', (true, (1, (0,))));
        unsafe {
            let _ = unsafe_a(args.0, args.1.0, args.1.1.0, args.1.1.1.0);
        }
        */

        let _ = unsafe_fn!(usize::unchecked_add, 1, 1);
        let _ = unsafe_method!(1u8, unchecked_add, 0);
        let _ = unsafe { 1_u8.unchecked_add(0) };
    }
}

// @TODO move to docs/tests
#[allow(unused)]
mod always_test {
    fn f(i: usize) -> usize {
        i + 1
    }

    fn g() -> fn(usize) -> usize {
        f
    }

    pub fn store_function_name() {
        let fun = f;
        f(0);

        let fun = g;
        fun()(1);

        let fun = usize::wrapping_add;
        fun(1, 0);
    }
}
