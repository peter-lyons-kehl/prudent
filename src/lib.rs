// @TODO nightly:
//
// https://github.com/rust-lang/rust/issues/143874
//
// #![feature(const_trait_impl)]
#![doc = include_str!("../README.md")]
#![cfg_attr(not(any(doc, test)), no_std)]
// This only refuses unsafe code in functions/expressions in this crate, not ones generated by this
// crate's macros.
#![cfg_attr(not(any(doc, test)), forbid(unsafe_code))]
#[cfg(doc)]
extern crate alloc;

/// Invoke am unsafe function.
///
/// There is NO extra enclosing pair of parenthesis `(...)` around the arguments. If they were, that
/// would be confusing and less readable when some parameters were tuples.
#[macro_export]
macro_rules! unsafe_fn {
    ( $fn:expr $(, $arg:expr)+ ) => {
        // Enclosed in a block, so that
        // 1. the result can be used as a value in an outer expression,and
        // 2. local variables don't conflict with the outer scope
        {
            let (tuple, fun) = ($crate::unsafe_fn!{~ $($arg),+ }, $fn);
            $crate::unsafe_fn! {~~~
                fun,
                tuple,
                ( $( $arg ),* ),
                (0)
            }
        }
    };
    ($fn:expr) => {
        {
            let fun = $fn;
            #[allow(unsafe_code)]
            unsafe {
                fun()
            }
        }
    };

    // Construct the tuple:
    (~ $first:expr, $($rest:expr),+ ) => {
        (
            $first, $crate::unsafe_fn!{ ~ $($rest),+ }
        )
    };
    (~ $last:expr) => {
        ($last,)
    };

    // Access tuple parts and call the function:
    (~~~ $fn:expr, $tuple:ident,
     ( $_first_arg:expr, $($other_arg:expr),+ ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        $crate::unsafe_fn!{ ~~~
            $fn, $tuple, ( $($other_arg),+ ),
            // Insert a new accessor to front (left): 0.
            (0),
            $(  // Prepend 1 to each supplied/existing accessor
                 ( 1, $($accessor_part),+ )
            ),*
        }
    };
    // All accessors are ready, so call the function:
    (~~~ $fn:expr, $tuple:ident,
     ( $_last_or_only_arg:expr ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        #[allow(unsafe_code)]
        unsafe {
            $fn( $(
                    $crate::unsafe_fn!{ ~~~~~ $tuple, $($accessor_part),+ }
                ),*
            )
        }
    };

    // Expand an accessor group/list to access a field in the tuple:
    (~~~~~ $tuple:ident, $($accessor_part:tt),* ) => {
        $tuple $(. $accessor_part )*
    };
}
//-------------

// No need to seal this trait, as it's implemented for all types.
/// Trait to accept/"normalize" a given receiver `self` from `T` to `&T`, or from `T` to `&mut T`.
/// See [AsRefOrMut::prudent_normalize_value_self_as_ref].
///
/// Blanket implemented for all types.
pub trait AsRefOrMut {
    /// Serves to accept/"normalize" a given receiver `self` that is of type `T`, `&T` or `&mut T`, so that
    /// the result is always of type `&T`. That way we can store its result in a local variable,
    /// even if `self` was passed in by value (rather than by reference) without moving it.
    ///
    /// We call this method with the standard dot notation, and that's why it has such a long name,
    /// so it doesn't conflict with user-defined inherent methods or with other traits. We do NOT
    /// call this as `AsRefOrMutOrValue::prudent_normalize_value_self_as_ref(...)`, as that would
    /// require the receiver expression to be a reference (rather than allowing a value), and that's
    /// a restriction we want to prevent.
    ///
    /// Used by [unsafe_method_ref].
    fn prudent_normalize_value_self_as_ref(&self) -> &Self {
        self
    }

    /// Like [AsRefOrMut::prudent_normalize_value_self_as_ref], but this "normalizes" the given
    /// receiver to a mutable reference.
    fn prudent_normalize_value_self_as_mut(&mut self) -> &mut Self {
        self
    }
}
impl<T> AsRefOrMut for T {}

/// Invoke an unsafe method that has a shared `Self` reference as a receiver: `&self`. Like
/// [unsafe_fn], but:
/// - This accepts a receiver `&self`, `&mut self` and `self` (which is then referenced, so it's
///   **not** moved/copied).
/// - This stores `self` in a variable outside of the generated `unsafe {...}`.
/// - $fn can **NOT** be an expression or a path (which doesn't work in standard methods calls), but
///   only an identifier.
#[macro_export]
macro_rules! unsafe_method_ref {
    ($self:expr, $fn:ident $(, $arg:expr)+ ) => {
        // Enclosed in a block, so that
        // 1. the result can be used as a value in an outer expression,and
        // 2. local variables don't conflict with the outer scope
        {
            use $crate::AsRefOrMut as _;
            let (tuple, receiver) = (
                $crate::unsafe_fn!{~ $($arg),+ },
                ( $self ).prudent_normalize_value_self_as_ref()
            );
            $crate::unsafe_method_ref! {~~~
                receiver,
                $fn,
                tuple,
                ( $( $arg ),* ),
                (0)
            }
        }
    };

    ($self:expr, $fn:ident ) => {
        {
            use $crate::AsRefOrMut as _;
            let receiver = ( $self ).prudent_normalize_value_self_as_ref();
            #[allow(unsafe_code)]
            unsafe {
                receiver. $fn()
            }
        }
    };

    // Access tuple parts and call the function:
    (~~~ $self:expr, $fn:ident, $tuple:ident,
     ( $_first_arg:expr, $($other_arg:expr),+ ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        $crate::unsafe_method_ref!{ ~~~
            $self, $fn, $tuple, ( $($other_arg),+ ),
            // Insert a new accessor to front (left): 0.
            (0),
            $(  // Prepend 1 to each supplied/existing accessor
                 ( 1, $($accessor_part),+ )
            ),*
        }
    };
    // All accessors are ready. $self was already evaluated (outside of unsafe {...}). So call the
    // function:
    (~~~ $self:expr, $fn:ident, $tuple:ident,
     ( $_last_or_only_arg:expr ),
     $( ( $($accessor_part:tt),+
        )
     ),*
    ) => {
        unsafe {
            $self. $fn( $(
                    $crate::unsafe_fn!{ ~~~~~ $tuple, $($accessor_part),+ }
                ),*
            )
        }
    };
}

//-------------

// @TODO
#[macro_export]
macro_rules! unsafe_static_set {
    ($static:path) => {
        (*&mut unsafe { $static })
    };
}

/// Deref a pointer (either `const` or `mut`) and yield a read-only reference.
///
/// If `$type` is given, it's expected to be the referenced type (NOT the given pointer, NOT the
/// target reference type) and the given pointer is cast to `* const $type`. `$type` may start with
/// `dyn`. `$type` may be a slice `[...]`.
#[macro_export]
macro_rules! unsafe_ref {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { &*ptr }
    }};
    ($ptr:expr, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { &*ptr as &$lifetime _ }
    }};
    ($ptr:expr, $type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $type;
        unsafe { &*ptr }
    }};
    ($ptr:expr, $ptr_type:ty, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let ptr = ptr as *const $ptr_type;
        unsafe { &*ptr as &$lifetime _ }
    }};
}

/// Deref a `mut` pointer and yield a `mut` reference.
///
/// Like for [unsafe_ref]: If `$type` is given, it's expected to be the referenced type (NOT the
/// given pointer, NOT the target reference type) and the given pointer is cast to `* const $type`.
/// `$type` may start with `dyn`. `$type` may be a slice `[...]`.
#[macro_export]
macro_rules! unsafe_mut {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &mut *ptr }
    }};
    ($ptr:expr, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &*ptr as &$lifetime _}
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as $ptr_type;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &*ptr}
    }};
    ($ptr:expr, $ptr_type:ty, $lifetime:lifetime) => {{
        let ptr = $ptr;
        let ptr = ptr as $ptr_type;
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe { &*ptr as &$lifetime _}
    }};
}

#[macro_export]
macro_rules! unsafe_val {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { *ptr }
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr;
        let ptr = ptr as $ptr_type;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { *ptr }
    }};
}

/*
-nightly version only
https://doc.rust-lang.org/std/keyword.use.html#ergonomic-clones
https://doc.rust-lang.org/std/clone/trait.UseCloned.html


#[macro_export]
macro_rules! unsafe_use {
    ($ptr:expr) => {{
        let ptr = $ptr;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { *ptr }
    }};
    ($ptr:expr, $ptr_type:ty) => {{
        let ptr = $ptr as $ptr_type;
        let _: *const _ = ptr; // Partial type check that $ptr yields a const pointer
        unsafe { *ptr }
    }};
}*/

/// Assign the given value to the location given in the pointer.
///
/// Needed, because we can't isolate:
///
/// `unsafe { *ptr } = value;`
///
/// We can't have a macro invocation on the left side (target) of an assignment operator `=` either,
/// so nothing like:
///
/// `unsafe_set!( pt ) = false;`
#[macro_export]
macro_rules! unsafe_set {
    ($ptr:expr, $value:expr) => {{
        let (ptr, value) = ($ptr, $value);
        let _: *mut _ = ptr; // Partial type check that $ptr yields a mut pointer
        unsafe {
            *ptr = value;
        }
    }};
}

//-------------
/// Cast the given value to the given type. Wrap the actual cast in `unsafe{...}` - but not wrapping
/// the given expression that yields the value. This allows any more `unsafe` code in the expression
/// to surface.
#[macro_export]
macro_rules! unsafe_cast {
    ($ptr:expr, $t:ty) => {{
        let ptr = $ptr;
        unsafe { &*ptr as $t }
    }};
}

//-------------

#[cfg(test)]
mod tests_fn_method {
    const unsafe fn unsafe_f(_: char, b: bool, _: u8, _: i32) -> bool {
        b
    }

    #[test]
    fn unsafe_fn() {
        //let tuple = unsafe_fn!{~  'c', true, 1, -5 };
        unsafe_fn!(unsafe_f, 'c', true, 1, -5);

        let _ = unsafe_fn!(usize::unchecked_add, 1, 1);

        let _ = unsafe_method_ref!(1u8, unchecked_add, 0);
        // Even the ordinary notation requires the receiver to be typed (with `_u8` postfix here):
        let _ = unsafe { 1_u8.unchecked_add(0) };
    }
}

#[cfg(test)]
mod tests_shadow_static {
    mod with_static_x {
        #[allow(unused)]
        static mut X: [bool; 2] = [true, false];
        fn _unsafe_set_x_0_simple_1(value: bool) {
            let value = value;

            // @TODO The expression (here: X) could include subexpressions (like array index) and
            // those may include `unsafe` code, too!
            unsafe { X[0] = value };
        }
        fn _unsafe_set_x_0_simple_2(value: bool) {
            *unsafe {
                // @TODO The expression (here: X) could include subexpressions (like array index)
                // and those may include `unsafe` code, too!
                #[allow(static_mut_refs)]
                &mut X[0]
                //
            } = value;

            (*unsafe {
                #[allow(static_mut_refs)]
                &mut X
            })[0] = value;

            // FLEXIBLE: <<~<<~<<
            (*&mut unsafe { X })[0] = value;

            (*&mut unsafe { X }) = [true, true];
        }
        fn _unsafe_set_x_0_store_ref(value: bool) {
            let value = value;
            // @TODO The expression (here: X) could include subexpressions (like array index) and
            // those may include `unsafe` code, too!
            let target_ref = &mut unsafe { X };

            target_ref[0] = value;
        }

        fn _unsafe_get_x_0_simple() -> bool {
            (unsafe { X })[0]
        }
        fn _unsafe_get_x_0_not_separating_indexes() -> bool {
            // An alias `use` does NOT "hide" the original symbol.
            //
            //use X as x;

            // let bindings can't shadow statics. Local functions or closures can't shadow statics
            // either.

            //( |X| X ) (unsafe {X} );

            //let X: _ = &mut unsafe { X };

            let target_ref = &mut unsafe { X };

            target_ref[0]
        }

        fn _unsafe_get_x_0_shadow_through_submodule() -> bool {
            let _local: char = 'l';

            mod shadow_x_level_one {
                use super::X;

                pub mod shadow_x_level_two {
                    // Or, instead of an import, just use `super::X` below. One less possible name
                    // conflict.
                    //
                    //use super::X as OUTER_X;

                    // @TODO requires a return type
                    //
                    // @TODO doesn't work if the static variable is identified with a path like
                    // `crate::mod_x::mod_y::STATIC_X``
                    pub fn _f() -> bool {
                        #[allow(non_snake_case)]
                        let X = &unsafe { super::X };

                        // @TODO this may capture variables from the caller's scope!
                        //
                        //X[0] || super::super::_local=='x'
                        if true {
                            panic!()
                        } else {
                            X[0]
                        }
                    }

                    /*trait With: Sized {
                        fn with<R>(self, _f: impl Fn (Self) -> R) -> R {
                            _f(self)
                        }
                    }
                    impl<T: Sized> With for T {}*/

                    pub fn _ff<T, R>(_f: impl Fn(T) -> R) -> R {
                        panic!()
                    }
                }
            }
            shadow_x_level_one::shadow_x_level_two::_f()
        }
    }
}

#[cfg(test)]
mod compile_checks_ref {
    use core::fmt::Display;
    const _B: bool = true;
    const _BS: [bool; 2] = [true, false];

    fn _ref() {}
    fn _ref_slice() {}
    fn _ref_dyn() {}

    fn _ref_lifetimed_slice() {}

    fn _ref_typed() {}
    fn _ref_typed_slice() {}
    fn _ref_typed_dyn() {
        let a: bool = true;
        let pt: *const dyn Display = &a as *const dyn Display;

        let _: &dyn Display = unsafe_ref!(pt, dyn Display);
        let _ = unsafe_ref!(pt, dyn Display);
    }
    fn _ref_typed_lifetimed() {
        let pt: *const bool = &_B as *const bool;

        let _: &'static bool = unsafe_ref!(pt, bool, 'static);
        let _ = unsafe_ref!(pt, bool, 'static);
    }
    fn _ref_typed_slice_lifetimed() {
        let pt: *const [bool] = &_BS as *const [bool];

        let _: &'static [bool] = unsafe_ref!(pt, [bool], 'static);
        let _ = unsafe_ref!(pt, [bool], 'static);
    }
    fn _ref_typed_dyn_lifetimed() {
        let pt: *const dyn Display = &_B as *const dyn Display;

        let _: &'static dyn Display = unsafe_ref!(pt, dyn Display, 'static);
        let _ = unsafe_ref!(pt, dyn Display, 'static);
    }
}

#[cfg(test)]
mod compile_checks_mut {
    fn _deref_mut_field_or_method() {
        let mut v: Vec<char> = vec!['a', 'b'];
        let _pt: *mut Vec<char> = &mut v as *mut Vec<char>;

        //unsafe_deref!(pt).push('c');
        //
        //let _ = unsafe_deref!(pt).len();
    }
}

#[cfg(test)]
mod compile_checks_val {
    fn _val() {
        let a: bool = true;
        let pt: *const bool = &a as *const bool;

        let _a2: bool = unsafe_val!(pt);
    }

    fn _val_typed() {
        let a: bool = true;
        let pt: *const bool = &a as *const bool;

        let _a2: bool = unsafe_val!(pt, *const bool);
    }
}

#[allow(unused)]
#[cfg(test)]
mod casting_tests {
    use std::fmt::Display;

    #[test]
    fn as_ref_() {
        let bslc: &[u8] = &[0u8, 1];
        let bpt_slc = bslc as *const _;
        let bptr: *const u8 = bpt_slc as _;

        //let bslc2 = unsafe { (bpt_slc as *const u8) as &u8};
        //let bslc3 = unsafe {bptr as &u8};
    }

    struct S;
    #[test]
    fn s() {
        let s = S;
        let pt = &s as *const S;
    }

    #[test]
    fn read_only() {
        let a: bool = true;
        let pt: *const bool = &a as *const bool;

        let rf: &bool = unsafe_ref!(pt);
    }

    #[test]
    fn mut_to_read_only() {
        let mut a: bool = true;
        let pt: *mut bool = &mut a as *mut bool;

        let rf: &bool = unsafe_ref!(pt);

        // Not allowed:
        //
        // unsafe { *pt  } = false;
        unsafe { *pt = false };

        // Move to a separate test:
        unsafe_set!(pt, false);
    }

    #[test]
    fn read_only_dyn_trait() {
        let rf: &'static dyn Display = &"abc";
        let pt: *const dyn Display = rf as *const dyn Display;

        let rf2: &dyn Display = unsafe_ref!(pt);
    }

    #[test]
    fn mut_to_mut() {
        {
            let mut a: bool = true;
            let pt: *mut bool = &mut a as *mut bool;

            let rf: &mut bool = unsafe_mut!(pt);
        }
        {
            let mut v: Vec<char> = vec!['a', 'b'];
            let pt: *mut Vec<char> = &mut v as *mut Vec<char>;
            unsafe_mut!(pt).push('c');
        }
    }

    #[test]
    fn mut_dyn_trait() {
        let mut v: Vec<char> = vec!['a', 'b'];
        let rf: &mut dyn AsMut<[char]> = &mut v;
        let pt: *mut dyn AsMut<[char]> = rf as *mut dyn AsMut<[char]>;

        let rf2: &mut dyn AsMut<[char]> = unsafe_mut!(pt);
    }
}

// @TODO move to docs/tests
#[allow(unused)]
mod always_test {
    fn f(i: usize) -> usize {
        i + 1
    }

    fn g() -> fn(usize) -> usize {
        f
    }

    pub fn store_function_name() {
        let fun = f;
        f(0);

        let fun = g;
        fun()(1);

        let fun = usize::wrapping_add;
        fun(1, 0);
    }
}

#[cfg(test)]
mod pass_flexi_receiver {
    struct SS {}
    impl SS {
        pub fn prudent_normalize_value_self_as_ref(&self) {}
    }
    fn _pass<T, R>(t: T, f: unsafe fn(T) -> R) -> R {
        unsafe { f(t) }
    }

    struct _S {}
    impl _S {
        unsafe fn _unsafe_method_ref_ref_no_args(&self) {}
        unsafe fn _unsafe_method_ref_mut_no_args(&mut self) {}
    }

    fn _consume() {
        let _s = _S {};

        //let _result = pass(s, |s| s.unsafe_method_ref_no_args());
        //let _result = pass(s, |s| 0usize);
    }

    fn _use_selfish() {
        {
            use crate::AsRefOrMut;
            let s = _S {};
            let as_ref = (s).prudent_normalize_value_self_as_ref();
            unsafe {
                as_ref._unsafe_method_ref_ref_no_args();
            }

            let _ = (&s).prudent_normalize_value_self_as_ref();
            let as_ref = (&s).prudent_normalize_value_self_as_ref();
            unsafe {
                as_ref._unsafe_method_ref_ref_no_args();
            }

            let s_ref = &s;
            (s_ref).prudent_normalize_value_self_as_ref(); // Flexible
        }
        {
            //let mut s = _S {};

            // nightly only:
            //
            // https://github.com/rust-lang/rust/issues/15701
            //
            // #![feature(stmt_expr_attributes)]
            //
            //(#[deny(unsafe_code)] s ).prudent_normalize_value_self_as_mut();

            //(#[deny(unsafe_code)] s ).prudent_normalize_value_self_as_mut();
        }
    }
}
